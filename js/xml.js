// js/xml.js — v0.9.300 — ГЕНЕРАЦИЯ И ИМПОРТ НА ОСНОВЕ МОДЕЛИ ДАННЫХ

const XML_VERSION = "v0.9.300";
window.XML_VERSION = XML_VERSION;

let xmlFormat = localStorage.getItem('xmlFormat') || 'pretty';

function setXMLFormat(val) {
  xmlFormat = val;
  localStorage.setItem('xmlFormat', val);
}

// Безопасная локализация
function loc(key, fallback = '') {
  if (L[key]) return L[key];
  console.warn(`MISSING LOC KEY: ${key}`);
  return `MISSING LOC KEY: ${key}`;
}

// === ГЕНЕРАЦИЯ XML ИЗ МОДЕЛИ ===
function generateXML() {
  const model = window.editorState.events[window.editorState.currentEventIndex].model;
  const eventId = document.getElementById('event-id')?.value.trim() || 'custom_event';

  let xml = `<ScriptedEvent identifier="${eventId}" commonness="100">`;

  if (xmlFormat === 'comments') {
    xml += `\n  <!-- ${loc('xmlGeneratedBy', 'Generated by Barotrauma RNG Builder v0.9.300')} -->`;
  }

  function walk(nodes, indent = "  ") {
    nodes.forEach(node => {
      const type = node.type;
      const params = node.params || {};

      if (type === 'spawn') {
        const item = params.item || 'revolver';
        const comment = xmlFormat === 'comments' ? ` <!-- ${item} -->` : '';
        xml += `\n${indent}  <SpawnAction itemidentifier="${item}" targetinventory="player" />${comment}`;
      } else if (type === 'creature') {
        const creature = params.creature || 'crawler';
        const count = params.count ?? 1;
        const randomize = params.randomize ?? true ? 'true' : 'false';
        const inside = params.inside ?? true;
        const comment = xmlFormat === 'comments' ? ` <!-- ${creature} x${count} -->` : '';
        xml += `\n${indent}  <SpawnCreature identifier="${creature}" count="${count}" randomizeposition="${randomize}" ${inside ? 'insidesub="true"' : 'outsidesub="true"'}" />${comment}`;
      } else if (type === 'affliction') {
        const aff = params.affliction || 'bleeding';
        const strength = params.strength ?? 15;
        const target = params.target || 'character';
        const comment = xmlFormat === 'comments' ? ` <!-- ${aff} ${strength} -->` : '';
        xml += `\n${indent}  <ApplyAffliction identifier="${aff}" strength="${strength}" target="${target}" />${comment}`;
      } else if (type === 'rng') {
        const chance = params.chance ?? 0.5;
        const chancePercent = (chance * 100).toFixed(1);
        const comment = xmlFormat === 'comments' ? ` <!-- ${chancePercent}% -->` : '';
        xml += `\n${indent}  <RNGAction chance="${chance}">${comment}`;
        xml += `\n${indent}    <Success>`;
        if (node.children && node.children.success) walk(node.children.success, indent + "      ");
        xml += `\n${indent}    </Success>`;
        xml += `\n${indent}    <Failure>`;
        if (node.children && node.children.failure) walk(node.children.failure, indent + "      ");
        xml += `\n${indent}    </Failure>`;
        xml += `\n${indent}  </RNGAction>`;
      }
    });
  }

  walk(model);
  xml += `\n</ScriptedEvent>`;

  const full = `<Randomevents>\n  <EventPrefabs>\n    ${xml}\n  </EventPrefabs>\n</Randomevents>`;

  let output = full;
  if (xmlFormat === 'minified') {
    output = full.replace(/\n\s*/g, '');
  }

  // === ВАЛИДАЦИЯ ===
  const issues = [];

  if (localStorage.getItem('validateXML') === 'true') {
    const hasActions = model.some(n => n.type !== 'rng' || (n.children && (n.children.success.length > 0 || n.children.failure.length > 0)));
    if (!hasActions) {
      issues.push(loc('validationEmptyEvent', 'Event is empty — nothing will spawn'));
    }

    // Шансы 0/100
    function checkBadChances(nodes) {
      nodes.forEach(node => {
        if (node.type === 'rng' && (node.params.chance <= 0 || node.params.chance >= 1)) {
          issues.push(loc('validationZeroChance', 'RNG with 0% or 100% chance — pointless'));
        }
        if (node.type === 'rng' && node.children) {
          checkBadChances(node.children.success);
          checkBadChances(node.children.failure);
        }
      });
    }
    checkBadChances(model);

    // RNG без действий
    function checkEmptyRNG(nodes) {
      nodes.forEach(node => {
        if (node.type === 'rng' && node.children && node.children.success.length === 0 && node.children.failure.length === 0) {
          issues.push(loc('validationNoItems', 'RNG has no actions in branches'));
        }
        if (node.type === 'rng' && node.children) {
          checkEmptyRNG(node.children.success);
          checkEmptyRNG(node.children.failure);
        }
      });
    }
    checkEmptyRNG(model);
  }

  // Дубликаты identifier (из модели)
  if (localStorage.getItem('checkDuplicateIDs') === 'true') {
    const ids = new Map();
    function collectIds(nodes) {
      nodes.forEach(node => {
        const id = node.params.item || node.params.creature || node.params.affliction;
        if (id) {
          if (ids.has(id)) {
            issues.push(`${loc('validationDuplicateId', 'Duplicate identifier')}: "${id}"`);
          } else {
            ids.set(id, true);
          }
        }
        if (node.type === 'rng' && node.children) {
          collectIds(node.children.success);
          collectIds(node.children.failure);
        }
      });
    }
    collectIds(model);
  }

  if (issues.length > 0) {
    let msg = loc('validationTitle', 'XML Validation — issues found:') + '\n\n' + issues.join('\n');
    msg += '\n\n' + loc('validationHint', 'These checks can be disabled in Settings → XML & Behavior');
    alert(msg);
  }

  document.getElementById('output').value = output;
}

// === ОБРАТНЫЙ ИМПОРТ XML → МОДЕЛЬ ===
function importFromXML() {
  const xmlText = document.getElementById('output').value.trim();
  if (!xmlText) {
    alert(loc('importXMLHint', 'Paste XML into the field below and click Import from XML'));
    return;
  }

  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlText, 'text/xml');

    const scriptedEvent = doc.querySelector('ScriptedEvent');
    if (!scriptedEvent) throw new Error('No ScriptedEvent found');

    document.getElementById('event-id').value = scriptedEvent.getAttribute('identifier') || 'imported_event';

    const newModel = [];

    function parseNode(element) {
      const tag = element.tagName;

      if (tag === 'RNGAction') {
        const chance = parseFloat(element.getAttribute('chance')) || 0.5;
        const nodeModel = nodeFactory.createModelRNG(chance);
        Array.from(element.children).forEach(child => {
          if (child.tagName === 'Success') Array.from(child.children).forEach(c => nodeModel.children.success.push(parseNode(c)));
          if (child.tagName === 'Failure') Array.from(child.children).forEach(c => nodeModel.children.failure.push(parseNode(c)));
        });
        return nodeModel;
      } else if (tag === 'SpawnAction') {
        const item = element.getAttribute('itemidentifier') || 'revolver';
        return nodeFactory.createModelSpawn(item);
      } else if (tag === 'SpawnCreature') {
        const creature = element.getAttribute('identifier') || 'crawler';
        const count = parseInt(element.getAttribute('count')) || 1;
        const randomize = element.getAttribute('randomizeposition') === 'true';
        const inside = element.getAttribute('insidesub') === 'true' || element.getAttribute('outsidesub') !== 'true';
        return nodeFactory.createModelCreature(creature, count, randomize, inside);
      } else if (tag === 'ApplyAffliction') {
        const aff = element.getAttribute('identifier') || 'bleeding';
        const strength = parseFloat(element.getAttribute('strength')) || 15;
        const target = element.getAttribute('target') || 'character';
        return nodeFactory.createModelAffliction(aff, strength, target);
      }
      return null;
    }

    Array.from(scriptedEvent.children).forEach(child => {
      const nodeModel = parseNode(child);
      if (nodeModel) newModel.push(nodeModel);
    });

    window.editorState.events[window.editorState.currentEventIndex].model = newModel;
    window.editorState.renderCurrentEvent();
    alert(loc('importSuccess', 'XML imported successfully'));
  } catch (err) {
    alert(loc('importError', 'XML parsing error'));
    console.error(err);
  }
}

window.generateXML = generateXML;
window.setXMLFormat = setXMLFormat;
window.importFromXML = importFromXML;
