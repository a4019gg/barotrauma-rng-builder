// js/xml.js — v0.9.200 — ПОДДЕРЖКА CREATURE, AFFLICTION, ОБРАТНЫЙ ПАРСИНГ, ЛОКАЛИЗАЦИЯ

const XML_VERSION = "v0.9.200";
window.XML_VERSION = XML_VERSION;

let xmlFormat = localStorage.getItem('xmlFormat') || 'pretty';

function setXMLFormat(val) {
  xmlFormat = val;
  localStorage.setItem('xmlFormat', val);
}

// Безопасная локализация с техническим fallback
function loc(key, fallback = '') {
  if (L[key]) return L[key];
  console.warn(`MISSING LOC KEY: ${key}`);
  return `MISSING LOC KEY: ${key}`;
}

// === ГЕНЕРАЦИЯ XML ===
function generateXML() {
  const eventId = document.getElementById('event-id')?.value.trim() || 'custom_event';

  let xml = `<ScriptedEvent identifier="${eventId}" commonness="100">`;

  if (xmlFormat === 'comments') {
    xml += `\n  <!-- ${loc('xmlGeneratedBy', 'Generated by Barotrauma RNG Builder v0.9.200')} -->`;
  }

  function walk(container, indent = "  ") {
    container.querySelectorAll(':scope > .node').forEach(node => {
      if (node.dataset.type === 'spawn') {
        const item = node.querySelector('.item-field')?.value.trim() || 'revolver';
        const comment = xmlFormat === 'comments' ? ` <!-- ${item} -->` : '';
        xml += `\n${indent}  <SpawnAction itemidentifier="${item}" targetinventory="player" />${comment}`;
      } else if (node.dataset.type === 'creature') {
        const creature = node.querySelector('.creature-field')?.value.trim() || 'crawler';
        const count = node.querySelector('.count-field')?.value || '1';
        const randomize = node.querySelector('.randomize-field')?.checked ? 'true' : 'false';
        const location = node.querySelector('.location-field')?.value || 'inside';
        const comment = xmlFormat === 'comments' ? ` <!-- ${creature} x${count} -->` : '';
        xml += `\n${indent}  <SpawnCreature identifier="${creature}" count="${count}" randomizeposition="${randomize}" ${location === 'outside' ? 'outsidesub="true"' : 'insidesub="true'}" />${comment}`;
      } else if (node.dataset.type === 'affliction') {
        const aff = node.querySelector('.aff-field')?.value.trim() || 'bleeding';
        const strength = node.querySelector('.strength-field')?.value || '15';
        const target = node.querySelector('.target-field')?.value || 'character';
        const comment = xmlFormat === 'comments' ? ` <!-- ${aff} ${strength} -->` : '';
        xml += `\n${indent}  <ApplyAffliction identifier="${aff}" strength="${strength}" target="${target}" />${comment}`;
      } else if (node.dataset.type === 'rng') {
        const chance = node.querySelector('.chance')?.value.trim() || '0.5';
        const chancePercent = (parseFloat(chance) * 100).toFixed(1);
        const comment = xmlFormat === 'comments' ? ` <!-- ${chancePercent}% -->` : '';
        xml += `\n${indent}  <RNGAction chance="${chance}">${comment}`;
        xml += `\n${indent}    <Success>`;
        const s = node.querySelector(`#c-${node.dataset.id}-s`);
        if (s) walk(s, indent + "      ");
        xml += `\n${indent}    </Success>`;
        xml += `\n${indent}    <Failure>`;
        const f = node.querySelector(`#c-${node.dataset.id}-f`);
        if (f) walk(f, indent + "      ");
        xml += `\n${indent}    </Failure>`;
        xml += `\n${indent}  </RNGAction>`;
      }
    });
  }

  walk(document.getElementById('root-children'));
  xml += `\n</ScriptedEvent>`;

  const full = `<Randomevents>\n  <EventPrefabs>\n    ${xml}\n  </EventPrefabs>\n</Randomevents>`;

  let output = full;
  if (xmlFormat === 'minified') {
    output = full.replace(/\n\s*/g, '');
  }

  // === ВАЛИДАЦИЯ ===
  const issues = [];

  if (localStorage.getItem('validateXML') === 'true') {
    if (!xml.includes('<SpawnAction') && !xml.includes('<RNGAction') && !xml.includes('<SpawnCreature') && !xml.includes('<ApplyAffliction')) {
      issues.push(loc('validationEmptyEvent', 'Event is empty — nothing will spawn'));
    }

    const badChances = [...xml.matchAll(/chance="([^"]+)"/g)]
      .map(m => parseFloat(m[1]))
      .filter(c => c <= 0 || c >= 1);
    if (badChances.length > 0) {
      issues.push(loc('validationZeroChance', 'RNG with 0% or 100% chance — pointless'));
    }

    document.querySelectorAll('.node.rng').forEach(node => {
      const chance = parseFloat(node.querySelector('.chance')?.value) || 0.5;
      const id = node.dataset.id;
      const sItems = document.querySelector(`#c-${id}-s`)?.querySelectorAll('.node').length || 0;
      const fItems = document.querySelector(`#c-${id}-f`)?.querySelectorAll('.node').length || 0;

      if (sItems === 0 && fItems === 0) {
        issues.push(loc('validationNoItems', 'RNG has no actions in branches'));
      }
    });
  }

  if (localStorage.getItem('checkDuplicateIDs') === 'true') {
    const ids = new Map();
    const matches = [...full.matchAll(/identifier="([^"]+)"/g)];
    for (const m of matches) {
      const id = m[1];
      if (ids.has(id)) {
        issues.push(`${loc('validationDuplicateId', 'Duplicate identifier')}: "${id}"`);
      } else {
        ids.set(id, true);
      }
    }
  }

  if (issues.length > 0) {
    let msg = loc('validationTitle', 'XML Validation — issues found:') + '\n\n' + issues.join('\n');
    msg += '\n\n' + loc('validationHint', 'These checks can be disabled in Settings → XML & Behavior');
    alert(msg);
  }

  document.getElementById('output').value = output;
}

// === ОБРАТНЫЙ ИМПОРТ XML → НОДЫ ===
function importFromXML() {
  const xmlText = document.getElementById('output').value.trim();
  if (!xmlText) {
    alert(loc('importXMLHint', 'Paste XML into the field below and click Import from XML'));
    return;
  }

  clearAll();

  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlText, 'text/xml');

    const scriptedEvent = doc.querySelector('ScriptedEvent');
    if (!scriptedEvent) throw new Error('No ScriptedEvent found');

    document.getElementById('event-id').value = scriptedEvent.getAttribute('identifier') || 'imported_event';

    const rootChildren = document.getElementById('root-children');

    function parseNode(element, containerPath = '') {
      if (element.tagName === 'RNGAction') {
        const chance = element.getAttribute('chance') || '0.5';
        addRNG(containerPath);
        const lastRNG = document.querySelector(`${containerPath ? '#c-' + containerPath : '#root-children'} > .node.rng:last-child`);
        if (lastRNG) lastRNG.querySelector('.chance').value = chance;

        const id = lastRNG.dataset.id;
        const sPath = id + '-s';
        const fPath = id + '-f';

        Array.from(element.children).forEach(child => {
          if (child.tagName === 'Success') Array.from(child.children).forEach(c => parseNode(c, sPath));
          if (child.tagName === 'Failure') Array.from(child.children).forEach(c => parseNode(c, fPath));
        });
      } else if (element.tagName === 'SpawnAction') {
        const item = element.getAttribute('itemidentifier') || 'revolver';
        addSpawn(containerPath);
        const last = document.querySelector(`${containerPath ? '#c-' + containerPath : '#root-children'} > .node.spawn:last-child`);
        if (last) last.querySelector('.item-field').value = item;
      } else if (element.tagName === 'SpawnCreature') {
        const creature = element.getAttribute('identifier') || 'crawler';
        const count = element.getAttribute('count') || '1';
        const randomize = element.getAttribute('randomizeposition') === 'true';
        const inside = element.getAttribute('insidesub') === 'true' || element.getAttribute('outsidesub') !== 'true';
        addCreature(containerPath);
        const last = document.querySelector(`${containerPath ? '#c-' + containerPath : '#root-children'} > .node.creature:last-child`);
        if (last) {
          last.querySelector('.creature-field').value = creature;
          last.querySelector('.count-field').value = count;
          last.querySelector('.randomize-field').checked = randomize;
          last.querySelector('.location-field').value = inside ? 'inside' : 'outside';
        }
      } else if (element.tagName === 'ApplyAffliction') {
        const aff = element.getAttribute('identifier') || 'bleeding';
        const strength = element.getAttribute('strength') || '15';
        const target = element.getAttribute('target') || 'character';
        addAffliction(containerPath);
        const last = document.querySelector(`${containerPath ? '#c-' + containerPath : '#root-children'} > .node.affliction:last-child`);
        if (last) {
          last.querySelector('.aff-field').value = aff;
          last.querySelector('.strength-field').value = strength;
          last.querySelector('.target-field').value = target;
        }
      } else {
        Array.from(element.children).forEach(child => parseNode(child, containerPath));
      }
    }

    Array.from(scriptedEvent.children).forEach(child => parseNode(child));

    updateAll();
    alert(loc('importSuccess', 'XML imported successfully'));
  } catch (err) {
    alert(loc('importError', 'XML parsing error'));
    console.error(err);
  }
}

window.generateXML = generateXML;
window.setXMLFormat = setXMLFormat;
window.importFromXML = importFromXML;
